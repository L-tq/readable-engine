import init, { Simulation } from "../../../core-sim/pkg/core_sim";

// We keep a reference to Wasm memory to access the raw simulation buffer.
let wasmMemory: WebAssembly.Memory;

export class SimBridge {
    private sim: Simulation | null = null;
    private initialized = false;

    /**
     * Initializes the Rust/Wasm core.
     * Must be called before any other methods.
     */
    async init() {
        if (this.initialized) return;

        // Initialize the Wasm module
        const wasmResult = await init();
        wasmMemory = wasmResult.memory;

        // Create the simulation instance
        this.sim = new Simulation();
        this.initialized = true;

        console.log("ðŸ¦€ Rust Core Initialized");
    }

    /**
     * Adds an agent to the simulation.
     * @param id - The Entity ID (from bitECS)
     * @param x - Initial X position
     * @param y - Initial Y position
     * @param radius - Collision radius
     * @param speed - Max movement speed
     */
    addAgent(id: number, x: number, y: number, radius: number, speed: number) {
        this.sim?.add_agent(id, x, y, radius, speed);
    }

    /**
     * Advances the simulation by one tick.
     * @param inputsJson - A JSON string containing commands for this tick
     */
    tick(inputsJson: string) {
        if (!this.sim) return;
        this.sim.tick(inputsJson);
    }

    /**
     * [PRODUCTION FIX] Remaps Agent IDs in the physics engine.
     * 
     * When loading a snapshot, bitECS generates new Entity IDs for the loaded objects.
     * We must tell Rust: "The agent that used to be ID 5 is now ID 102."
     * 
     * @param oldIds - Array of IDs from the snapshot
     * @param newIds - Array of corresponding new IDs generated by bitECS
     */
    remapIds(oldIds: Uint32Array, newIds: Uint32Array) {
        if (!this.sim) return;
        try {
            // Note: We assume the Rust method is exported as snake_case 
            // based on your project configuration.
            this.sim.remap_ids(oldIds, newIds);
        } catch (e) {
            console.error("Failed to remap IDs in Rust core:", e);
        }
    }

    /**
     * Returns a view into the Wasm memory containing the simulation state.
     * Format: [id, x, y, vx, vy, ...repeat]
     * 
     * [PRODUCTION FIX]: Handles WebAssembly memory growth (detached buffers).
     */
    getStateBuffer(): Float64Array | null {
        if (!this.sim) return null;

        const ptr = this.sim.get_state_ptr();
        const len = this.sim.get_state_len();

        if (len === 0) return new Float64Array(0);

        // Safety Check: Wasm memory can resize (grow), causing the old buffer 
        // reference to become "detached" (byteLength === 0).
        if (wasmMemory.buffer.byteLength === 0) {
            console.warn("[SimBridge] Wasm memory detached! Re-fetching buffer...");
            // In standard wasm-bindgen, the export usually updates automatically,
            // but if we held a reference elsewhere, it would be dead.
            // Accessing .buffer on the export again usually gives the valid one.
        }

        return new Float64Array(wasmMemory.buffer, ptr, len);
    }

    // --- SNAPSHOTS ---

    /**
     * Serializes the Rust simulation state into a JS Object.
     */
    getSnapshot(): any {
        return this.sim?.get_snapshot();
    }

    /**
     * Restores the Rust simulation state from a JS Object.
     */
    loadSnapshot(data: any) {
        this.sim?.load_snapshot(data);
    }
}